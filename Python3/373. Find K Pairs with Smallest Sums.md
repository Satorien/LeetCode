## Step 1. Initial Solution

- 全部の和の可能性を調べようと思うとあまりに遅くメモリも必要
    - 並べてある状態で数えて行ってk個見つかったら終了が理想
    - Heapを使えば上手く行ける？
        - nlargestとかで並び替えるにしてもどうやってリストに入れていけば良いのか？
- 最小が分かった状態で回していくにはどうすれば良いのか？
    - 和を表にしてみた時、インデックス増える方向のマスの和はどちらも元のマスの和より大きい
        - どちらかを選んでいく感じ？
            - 単純に選んでいくと網羅的に探索できず上手くいかない
    - 何通りか試してみるも上手く行くものがないまま40分経ったので一旦全探索を実装
        - メモリエラー（タイムアウトにもなるらしい）
- 分からないまま1時間消費してしまったので答えを見る
    - 答えをheappopしたら、その次の2マスを候補のheapにpushする
    - 候補の中からまたheappopする
    - 候補が被らないようにsetで訪れたマスを管理
        - 確かにこれなら全ての問題を解消している
        - 全然思いつかなかったが、二分木の使い方として同じパターンが来たら解けるようになりたい

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        sum_pair: List[(int, List[int])] = [(nums1[0]+nums2[0], [0,0])]
        visited = set()
        ans: List[List[int]] = []
        nums1_len = len(nums1)
        nums2_len = len(nums2)

        while k > 0:
            _, [idx1, idx2] = heapq.heappop(sum_pair)
            ans.append([nums1[idx1], nums2[idx2]])
            k -= 1

            if idx1 < nums1_len - 1 and (idx1+1, idx2) not in visited:
                visited.add((idx1+1, idx2))
                heapq.heappush(sum_pair, (nums1[idx1+1] + nums2[idx2], [idx1+1, idx2]))
            if idx2 < nums2_len - 1 and (idx1, idx2+1) not in visited:
                visited.add((idx1, idx2+1))
                heapq.heappush(sum_pair, (nums1[idx1] + nums2[idx2+1], [idx1, idx2+1]))
        return ans
```

### Complexity Analysis

- 時間計算量：O(k log k)
    - k回のpop, pushをすれば行ける
        - pop, pushしてheap構造を保つにはlog k必要
- 空間計算量：O(k)
    - 答えに格納する分＋いくらか

## Step 2. Alternatives

- 重複処理をまとめたり、問題に与えられていないエッジケースに対応するようにコードを書いている人もいた
    - そういう意識は仕事をする上では必要そう
    - 言われなくても対応できるようにしたい
- タプルの型ヒントの付け方も修正

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return None
        self.nums1 = nums1
        self.nums2 = nums2
        self.len1 = len(nums1)
        self.len2 = len(nums2)
        self.sum_pair: List[Tuple[int, int, int]] = [(nums1[0]+nums2[0], 0, 0)]
        self.visited = set((0,0))
        result: List[List[int]] = []

        while k > 0:
            _, i, j = heapq.heappop(self.sum_pair)
            result.append([nums1[i], nums2[j]])
            k -= 1
            self.push_pair(i + 1, j)
            self.push_pair(i, j + 1)
        return result

    def push_pair(self, i: int, j: int)->None:
        if i < self.len1 and j < self.len2 and (i, j) not in self.visited:
            self.visited.add((i, j))
            heapq.heappush(self.sum_pair, (self.nums1[i] + self.nums2[j], i, j))
```

- 一旦nums1の全てとnums2[0]のペアを候補に入れて、候補から順に引き抜かれたところのnums2のインデックスを上げて候補に追加する方法もある
    - 途中で考えていた方法はこれに近いものがあった
    - 絞った候補から選んで候補を更新する、という考えとしては根底は同じ
    - 最初にlen(nums1)分のheappushがあるので少し余分に時間はかかる
    - メモリ的にもlen(nums1)+k必要
- 上のやり方をより洗練させて、visitedを使わずにやる方法がある
    - nums1×nums2の表に見立てて、popがnums2[0]だったときだけ縦横に広げる
    - それ以外は縦だけに広げる

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return None
        self.nums1 = nums1
        self.nums2 = nums2
        self.len1 = len(nums1)
        self.len2 = len(nums2)
        self.sum_pair: List[Tuple[int, int, int]] = [(nums1[0]+nums2[0], 0, 0)]
        result: List[List[int]] = []

        while k > 0:
            _, i, j = heapq.heappop(self.sum_pair)
            result.append([nums1[i], nums2[j]])
            self.add_candidate_from(i, j)
            k -= 1
        return result

    def add_candidate_from(self, i: int, j: int)->None:
        if j == 0 and i + 1 < self.len1:
            heapq.heappush(self.sum_pair, (self.nums1[i + 1] + self.nums2[0], i + 1, 0))
        if j + 1 < self.len2:
            heapq.heappush(self.sum_pair, (self.nums1[i] + self.nums2[j + 1], i, j + 1))
```

## Step 3. Final Solution

- 二つのリストがあってそのペアを考える、と言われたら表をイメージしたい

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        sum_pair: List[Tuple[int, int, int]] = [(nums1[0] + nums2[0], 0, 0)]
        result: List[List[int]] = []
        while len(result) < k:
            _, i, j = heapq.heappop(sum_pair)
            result.append([nums1[i], nums2[j]])
            if j == 0 and i + 1 < len(nums1):
                heapq.heappush(sum_pair, (nums1[i + 1] + nums2[j], i + 1, 0))
            if j + 1 < len(nums2):
                heapq.heappush(sum_pair, (nums1[i] + nums2[j + 1], i, j + 1))
        return result
```
