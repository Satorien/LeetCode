## Step 1. Initial Solution

- 初めはfor文で前から見て行って既に登場したやつだったら候補から消すイメージだったが重複するということを覚えておけば十分そう
- 一つのSetだと処理しにくそうなので二つで実装
- enumerateを使うかfindを使うかで少し悩んだがインデックスが必要になるのは一か所だけなのでfindの方がfor文の処理は分かりやすいと感じた

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        unique_chars: Set[str] = set()
        duplicate_chars: Set[str] = set()
        for char in s:
            if char in unique_chars:
                duplicate_chars.add(char)
            unique_chars.add(char)
        for char in s:
            if char not in duplicate_chars:
                return s.find(char)
        return -1
```

### Complexity Analysis

- 時間計算量：O(n)
    - sの長さn分のループとsetの演算log k
    - kは最大でも26なので定数倍の時間
- 空間計算量：O(1)
    - 最大でも26文字分のset2つ分

## Step 2. Alternatives

- 辞書型でカウントする方法も考えていた
    - 2回目のfor文をkeys()で回しているが、[Python3.6](https://docs.python.org/ja/3.6/library/stdtypes.html#dict-views:~:text=%E3%82%AD%E3%83%BC%E3%81%A8%E5%80%A4%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E3%81%AF%E3%81%82%E3%82%8B%E4%BB%BB%E6%84%8F%E3%81%AE%E9%A0%86%E5%BA%8F%E3%81%A7%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%83%88%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%81%8C%E3%80%81%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%8F%E3%80%81%20Python%20%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E5%A4%89%E3%82%8F%E3%82%8A%E3%80%81%E8%BE%9E%E6%9B%B8%E3%81%B8%E3%81%AE%E6%8C%BF%E5%85%A5%E3%82%84%E5%89%8A%E9%99%A4%E3%81%AE%E5%B1%A5%E6%AD%B4%E3%81%AB%E4%BE%9D%E5%AD%98%E3%81%97%E3%81%BE%E3%81%99%E3%80%82)以前では実装依存のためOrderedDictが推奨
    - [https://docs.python.org/ja/3/library/stdtypes.html#dict:~:text=バージョン 3.7 で変更%3A 辞書の順序が挿入順序であることが保証されるようになりました。この振る舞いは CPython 3.6 の実装詳細でした。](https://docs.python.org/ja/3/library/stdtypes.html#dict:~:text=%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%203.7%20%E3%81%A7%E5%A4%89%E6%9B%B4%3A%20%E8%BE%9E%E6%9B%B8%E3%81%AE%E9%A0%86%E5%BA%8F%E3%81%8C%E6%8C%BF%E5%85%A5%E9%A0%86%E5%BA%8F%E3%81%A7%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E4%BF%9D%E8%A8%BC%E3%81%95%E3%82%8C%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%E3%81%93%E3%81%AE%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%81%AF%20CPython%203.6%20%E3%81%AE%E5%AE%9F%E8%A3%85%E8%A9%B3%E7%B4%B0%E3%81%A7%E3%81%97%E3%81%9F%E3%80%82)

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        char_to_count: Dict[str, int] = defaultdict(int)
        for char in s:
            char_to_count[char] += 1
        for char in char_to_count.keys():
            if char_to_count[char] == 1:
                return s.find(char)
        return -1
```

- カウントを保持する代わりに有効なインデックスだけ保持するという方法もありそう
    - 有効じゃない場合をNoneにするかは少し悩ましい

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        char_to_index: Dict[str, Optional(int)] = {}
        for i, char in enumerate(s):
            if char in char_to_index:
                char_to_index[char] = None
                continue
            char_to_index[char] = i
        for index in char_to_index.values():
            if index is not None:
                return index
        return -1
```

ここからは他人のも参考に

- 初めに26個の枠を用意しておくという手もある
    - `ord(c)-ord('a')` などを使うと異常入力（lowercase以外）の判定が楽そう

```python
class Solution:
    def firstUniqChar(self,s:str)->int:
        freq = [0] * 26
        for c in s:
            char_index = ord(c) - ord('a')
            if char_index < 0 or 25 < char_index:
                raise ValueError("Invalid character")
            freq[char_index] += 1
        for i, c in enumerate(s):
            if freq[ord(c)-ord('a')] == 1:
                return i
        return -1
```

- その他
    - Counter
    - rfindで一致するかを確かめる方法
        - https://github.com/chanseok-lim/arai60/pull/8/files#diff-5e4287a02e3f11dbbbe1217cb91b9370bcf7798cdde8ce6e7c1729817e53c0fcR83
    - LRU Cacheの実装
        - https://github.com/chanseok-lim/arai60/pull/8/files#diff-5e4287a02e3f11dbbbe1217cb91b9370bcf7798cdde8ce6e7c1729817e53c0fcR93
        - 実際のコードを見つけられなかったので一旦スルー

## Step 3. Final Solution

- indexを保持しておくのが一番速そう
    - 重複する分は-1にした

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        char_index: Dict[str, int] = {}
        for index, char in enumerate(s):
            if char in char_index:
                char_index[char] = -1
                continue
            char_index[char] = index
        for index in char_index.values():
            if index != -1:
                return index
        return -1
```
