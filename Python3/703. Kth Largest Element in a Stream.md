## Step 1. Initial Solution

- 最初の入力を並び替えて大きいk個を保存しておく
- 追加されたら正しい場所に挿入してあげる
    - k個を越えてる分を削除
- （ここは盛大な勘違いだが）k個に足りない分はNoneを格納しておく
    - 元から入れておいて後で追い出す方法が良さそう
- addを実装するならNoneを格納したリストに対して入力numsをaddしていくので良さそう

```python
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k: int = k
        self.k_largest: List[int] = [None]*k
        while nums:
            self.add(nums.pop())

    def add(self, val: int) -> int:
        for idx in range(self.k):
            if self.k_largest[idx] is None or self.k_largest[idx] < val:
                self.k_largest.insert(idx, val)
                self.k_largest.pop()
                break
        return self.k_largest[-1]

# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```

### Complexity Analysis

- 時間計算量：O(n^2)
    - 初期化で最大O(n^2)、addではO(n)
        - 入れる場所を見つけるまでに最大O(n)
        - 挿入の実行で更にO(n)
- 空間計算量：O(n)
    - リストの長さは最大k+1

## Step 2. Alternatives

- まず解答を見て、誰もNoneで埋めるというようなことをしていないので自分の勘違いに気づく
    - そもそもの条件でk≤nums.length+1とあるので、Noneを出力しないといけない場面はない
    - あったとしても、リストの長さが足りない時にNoneを返すという実装で十分
- その他の見直し
    - numsを破壊しないようにした
    - 線形探索をやめて実装済みのソートを使うようにした

```python
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k: int = k
        queue: List[int] = copy.deepcopy(nums)
        self.k_largest: List[int] = []
        while queue:
            self.add(queue.pop())

    def add(self, val: int) -> int:
        self.k_largest.append(val)
        self.k_largest.sort()
        if len(self.k_largest) > self.k:
            self.k_largest.pop(0)
        return self.k_largest[0]
```

- 自分でbinary_searchを実装した場合

```python
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k: int = k
        queue: List[int] = copy.deepcopy(nums)
        self.k_largest: List[int] = []
        while queue:
            self.add(queue.pop())

    def add(self, val: int) -> int:
        insert_idx: int = self.binary_search(self.k_largest, val)
        self.k_largest.insert(insert_idx, val)
        if len(self.k_largest) > self.k:
            self.k_largest.pop(0)
        return self.k_largest[0]

    def binary_search(self, li: List[int], val: int) -> int:
        if not li:
            return 0

        idx: int = len(li)//2
        if li[idx] == val:
            return idx
        elif li[idx] > val:
            return self.binary_search(li[:idx], val)
        elif li[idx] < val:
            return idx + 1 + self.binary_search(li[idx+1:], val)
```

- 後から調べたらbisect.insort(self.k_largest, val)の方が良さそう
    - 理論的には近いはずだがbuilt-inの二分探索は速い
        - あとで実装を確認する

```python
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k: int = k
        queue: List[int] = copy.deepcopy(nums)
        self.k_largest: List[int] = []
        while queue:
            self.add(queue.pop())

    def add(self, val: int) -> int:
        bisect.insort(self.k_largest, val)
        if len(self.k_largest) > self.k:
            self.k_largest.pop(0)
        return self.k_largest[0]
```

- Heapを使った解法
    - 知っていればこれが一番速そう
    - 細かい実装も時間を見つけて要確認
    - 時間計算量
        - 初期化ではO(n)、addではO(log n)

```python
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k: int = k
        self.heap_nums: List[int] = nums
        heapq.heapify(self.heap_nums)
        while len(self.heap_nums) > k:
            heapq.heappop(self.heap_nums)

    def add(self, val: int) -> int:
        heapq.heappush(self.heap_nums, val)
        if len(self.heap_nums) > self.k:
            heapq.heappop(self.heap_nums)
        return self.heap_nums[0]
```

## Step 3. Final Solution

- 折角なのでheapで実装

```python
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.top_k_heap: List[int] = copy.deepcopy(nums)
        heapq.heapify(self.top_k_heap)
        while len(self.top_k_heap) > k:
            heapq.heappop(self.top_k_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.top_k_heap, val)
        if len(self.top_k_heap) > self.k:
            heapq.heappop(self.top_k_heap)
        return self.top_k_heap[0]
```
