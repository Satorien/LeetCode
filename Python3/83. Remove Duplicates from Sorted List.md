## Step 1. Initial Solution

### Notes
- 元のheadを返すようにしながら連結リストの中身を変えることが目的
  - キーアイデア：`current.next`に`current.next.next`を代入する
  - `current.next`を書き換えることで元のListNodeが書き換わる
- 入力が空の時の考慮も忘れないようにする
```Python3
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head

        current = head
        while current.next:
            if current.val == current.next.val:
                current.next = current.next.next
            else:
                current = current.next
        return head

```

### Complexity Analysis

- Time: O(n)
    - 連結リストを一通り見る
- Space: O(1)
    - `head`と`current`だけ

## Step 2. Alternatives

- `None`であることを直接判定した方が分かりやすい
- 返すべきListNodeをコピーしておいてループを回すのもあり

```Python3
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        ret = head
        while head.next is not None:
            if head.val == head.next.val:
                head.next = head.next.next
            else:
                head = head.next
        return ret

```

## Step3. Final Solution
### Other Thoughts
- if/elseで繋ぐよりcontinueの方が分かりやすい
- is Noneは分かりやすいが is not Noneはかえって分かりにくい

### Ver 3.
```Python3
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        current_node = head
        while current_node.next:
            if current_node.next.val == current_node.val:
                current_node.next = current_node.next.next
                continue
            current_node = current_node.next
        return head
```

# Additional Thoughts
- ListNodeはミュータブルな型なので新しいheadが作られずにhead.nextを変更できる

# Reference
https://hayapenguin.com/notes/arai60
https://realpython.com/pointers-in-python/#simulating-pointers-in-python
