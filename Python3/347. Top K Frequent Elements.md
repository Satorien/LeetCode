## Step 1. Initial Solution

- 辞書型に入れてカウントし、それを並び替えてインデックスを使えば行けそう
- 久しぶりにdict()に触るのでよく分かっていない
    - キーに入っていない値を確かめるには？
        - 直接呼んだらエラー？None？
    - 実装を進める中でエラーが絶えなかったのでドキュメントを確認
        - dict_nums.keysはbuilt-in function
        - iterableとして使うならdict_nums.keys()
            - 初歩的だが知らないのは致命的だった
- 次に並び替え
    - numpyのargsortのようなものがあれば楽だがなさそう
    - sortして、k番目のカウントを取り出す
    - k番目のカウント以上の要素をリストにして返す

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dict_nums = dict()
        k_freq = []
        for num in nums:
            if num not in dict_nums:
                dict_nums[num] = 0
            dict_nums[num] += 1
        sort_count: List[int] = dict_nums.values()
        min_freq: int = sorted(sort_count)[-k]
        for num in dict_nums:
            if dict_nums[num] >= min_freq:
                k_freq.append(num)
        return k_freq
```

### Complexity Analysis

- 時間計算量：O(n log n)
    - forループでO(n)、sortでO(n log n)
- 空間計算量：O(k)

## Step 2. Alternatives

- ドキュメントを確認して曖昧だった部分を解消
    - sortedの引数に関数を入れてその値で比較できるらしい
    - これがシンプルで良い

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dict_nums = dict()
        for num in nums:
            if num not in dict_nums:
                dict_nums[num] = 0
            dict_nums[num] += 1
        return sorted(dict_nums.keys(), key=dict_nums.get)[-k:]
```

- sortedのkeyにLambda関数を入れて任意のiterableに対応できる方法もある
    - itemsがviewobjectを返す

```python
sorted(dict_nums.items(), key=lambda item: item[1])
```

- if文を使わない方法も見かけた
    - 計算量的には同程度
    - dict_nums.setdefault(num,0) : keyがなければ0で埋める
    - defaultdict(int) : keyを呼ぶときに0から始まる
        - Counter()でも同じ
- Counter()のメソッドを使えばこの書き方も可能

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        return [num for num, count in Counter(nums).most_common(k)]
```

- sortに関するあれこれ
    - sortedは任意のiterableを処理できるが、sortはlistのみ
    - sortedはobject.__lt__を用いて比較しているので、これを書き換えれば十分
        - 当然PEP8的には比較演算子は全て定義するべき
    - keyに与える関数は別のオブジェクトの関数でも良い
    - heapq.nlargest(n, iterable, key)やheapq.nsmallest(n, iterable, key)でも等価な機能を実現
    - heappushとheappopでもsort可能

## Step 3. Final Solution

- 汎用性が高そうな方法を選択

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        frequency = defaultdict(int)
        for num in nums:
            frequency[num] += 1
        return sorted(frequency, key=frequency.get)[-k:]
```
