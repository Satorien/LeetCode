## Step 1. Initial Solution

- Linked List Cycleと似ている
    - slowとfastを使えそう
- そのままfastで進んでいって被ったところを返す？
    - それだと追い越してしまう可能性がある
    - 追い越すとしても一個分まで
    - 追いついたら一個前も確かめる？
        - 一個前は難しそうなので一個先が良い
- 被ったことのチェックはsetで行うと速い
- 実装してみたらエラー
    - 一個先を確かめるのでそのノードがNoneじゃないことを確認する必要があった

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow: ListNode = head
        fast: ListNode = head
        slow_history: set = set()
        while fast is not None and fast.next is not None:
            slow_history.add(slow)
            slow = slow.next
            fast = fast.next.next
            if fast in slow_history:
                return fast
            elif fast is not None and fast.next in slow_history:
                return fast.next
        return None
```

### Complexity Analysis

- 時間計算量：O(n)
    - setに対するin演算は定数時間
    - whileの処理がn/2からnまでありうる
- 空間計算量：O(n)
    - 最大でn個のオブジェクトをsetに入れる
        
        > [`PyDictObject`](https://docs.python.org/ja/3.13/c-api/dict.html#c.PyDictObject) と同じように、小さい集合(set)に対しては(タプルのように)固定サイズであり、そうでない集合に対しては(リストと同じように)可変長のメモリブロックを用います。([Ref](https://docs.python.org/ja/3.13/c-api/set.html#set-objects))
