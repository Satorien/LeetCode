## Step 1. Initial Solution

- Linked List Cycleと似ている
    - slowとfastを使えそう
- そのままfastで進んでいって被ったところを返す？
    - それだと追い越してしまう可能性がある
    - 追い越すとしても一個分まで
    - 追いついたら一個前も確かめる？
        - 一個前は難しそうなので一個先が良い
- 被ったことのチェックはsetで行うと速い
- 実装してみたらエラー
    - 一個先を確かめるのでそのノードがNoneじゃないことを確認する必要があった

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow: ListNode = head
        fast: ListNode = head
        slow_history: set = set()
        while fast is not None and fast.next is not None:
            slow_history.add(slow)
            slow = slow.next
            fast = fast.next.next
            if fast in slow_history:
                return fast
            elif fast is not None and fast.next in slow_history:
                return fast.next
        return None
```

### Complexity Analysis

- 時間計算量：O(n)
    - setに対するin演算は定数時間
    - whileの処理がn/2からnまでありうる
- 空間計算量：O(n)
    - 最大でn個のオブジェクトをsetに入れる
        
        > [`PyDictObject`](https://docs.python.org/ja/3.13/c-api/dict.html#c.PyDictObject) と同じように、小さい集合(set)に対しては(タプルのように)固定サイズであり、そうでない集合に対しては(リストと同じように)可変長のメモリブロックを用います。([Ref](https://docs.python.org/ja/3.13/c-api/set.html#set-objects))
        > 

## Step 2. Alternatives

- フロイドの循環検出法というものがあるらしい
    - https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.jfs03xpyyrfl
        - ウサギとカメを進ませて、衝突した点をベースに考える
        - カメがサイクルを一周して衝突点に戻ってくるのにかかる時間は、カメがスタートしてから衝突点に至るのにかかる時間と一緒
            - 途中からは同じノードを進む
            - 合流点がサイクルの始点

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow: ListNode = head
        fast: ListNode = head
        while fast is not None and fast.next is not None:
            slow = slow.next
            fast = fast.next.next
            if slow is fast:
                break
        else:
            return None
        
        delay_slow: ListNode = head
        while slow is not delay_slow:
            slow = slow.next
            delay_slow = delay_slow.next
        return slow
```

- 141を解いている分、思考が囚われてしまっていたがシンプルにnodeを進めてsetに入れていくのが王道と思われる
    - 自分のStep 1のやり方だとメモリ使用量の期待値は下げられるがそれほど重要な観点ではない
- 再帰で解く方法もあるらしい
    - 再帰で解くのは考えないがちなので一応検討した方が良い
        - 一定の深さに収まるなら使っても良い？
        - 今回は流石にwhileで回す方が良いだろう

## Step 3. Final Solution

- シンプルな書き方に落ち着いた
    - メモリの制約があるならフロイドの循環検出法で行く

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node: ListNode = head
        visited: set = set()
        while node is not None:
            visited.add(node)
            node = node.next
            if node in visited:
                return node
        return None
```
