## Step 1. Initial Solution

- 完全に新しいリストを作ることやnode.valを書き換える案も考えた
    - ただ、問題文から読み取れる内容としては元のListNodeからDuplicateを取り除くことが趣旨
    - node.nextを付け替える方法で実装
- 最初のノードを取り除けるようにdummy_headを利用
- 重複値の除去をwhile文の中のwhile文でやることも考えた
    - ただ、結局node.nextがNoneじゃないことを確認する必要があるため同じ条件文を書くくらいなら外のループからもう一回入り直す方が楽
- 重複値の発見をduplicate_valに格納
    - これも見つけたらループ内処理を上に戻ってやり直す
    - 重複値がなくなってから処理することで再発見することを防げるので重複値除去のあとにする

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy_head: ListNode = ListNode(-101, head)
        node: ListNode = dummy_head
        duplicate_val = -101 # Note: -100 <= Node.val <= 100
        while node.next is not None:
            if node.next.val == duplicate_val:
                node.next = node.next.next
                continue
            if node.next.next is not None and node.next.val == node.next.next.val:
                duplicate_val = node.next.val
                continue
            node = node.next
        return dummy_head.next
            
```

- 所要時間：32分
- 少し丁寧に考えすぎたが1発目でエラーなしで動かせた
    - 頭の中でエラーが出ることを想像して書けた

### Complexity Analysis

- 時間計算量：O(n)
    - 連結リスト一通り＋重複発見回ループが回る
- 空間計算量：O(1)
    - 新たにリストを作ったりはしていない

## Step 2. Alternatives

- 事前に検討した通り、他の方法としては新しくリストを作って値やノードを入れていく方法があった
    - Stackを使った解法は分かりやすいが答えを出力する形式の都合上、ListNodeに格納していかないと二度手間ではある
- 再帰を使う方法もある
    - whileループの代わりにどんどん深くして行って進めるらしい
    - あまりメリットを感じなかった
- nodeという命名は微妙
    - 実際に何を意味しているのか分からない
    - 役割としては既に確定しているノード、あるいは変えることのない始点のノードという感じ
        - checked_nodeにする
        - prevとcurrentを使って分けている人もいる
- 101にマジックナンバー感がないか
    - 一応コメントを付けたが分かりにくい？
    - dummy_head.valは確認することはないので省略しても良い
- 構造が少し周りと違う
    
    ```python
    while N:
    	if A:
    		X
    	if B:
    		Y
    	Z
    ```
    
    という構造を取っていたが、周りでは
    
    ```python
    while N:
    	if A:
    		while A and N:
    			X
    	else:
    		Y
    	Z
    ```
    
    という構造の人が多い
    
    - 試しに二重ループで実装
    
    ```python
    class Solution:
        def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
            dummy_head: ListNode = ListNode()
            prev_node: ListNode = dummy_head
            current_node: ListNode = head
            duplicate_val = -101 # Note: -100<=Node.val<=100
            while current_node is not None:
                if current_node.next is not None and current_node.val == current_node.next.val:
                    duplicate_val = current_node.val
                    while current_node is not None and current_node.val == duplicate_val:
                        current_node = current_node.next
                    prev_node.next = None
                    continue
                prev_node.next = current_node
                prev_node = prev_node.next
                current_node = current_node.next
            return dummy_head.next
    ```
    
    - duplicate_valを記録せずに最後にnextを返して飛ばす方法の方が多い

## Step 3. Final Solution

- 元の解放の変数名などを修正したものに落ち着いた

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy_head: ListNode = ListNode(next=head)
        checked_node: ListNode = dummy_head
        duplicate_val = -101 # Note: -100 <= Node.val <= 100
        while checked_node.next is not None:
            if checked_node.next.val == duplicate_val:
                checked_node.next = checked_node.next.next
                continue
            if checked_node.next.next is not None and checked_node.next.val == checked_node.next.next.val:
                duplicate_val = checked_node.next.val
                continue
            checked_node = checked_node.next
        return dummy_head.next
```
