## Step 1. Initial Solution

- いくつかやり方はありそう
    - それぞれのリストからセットを作ってその積集合を取る
        - やっている処理はほぼ同じなので見通しが良いこちらを採用
    - 一つ分のセットを作って、もう一つでfor文を回して新しくセットを作る
    - リストのまま上をやる方法

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1: set = set()
        set2: set = set()
        for num in nums1:
            set1.add(num)
        for num in nums2:
            set2.add(num)
        intersection: set = set1 & set2
        return list(intersection)
```

### Complexity Analysis

- 時間計算量：O(m+n)
    - 一つ目のset化O(m)、二つ目のset化O(n)、intersectionの処理O(m+n)、最後のリスト化O(m+n)
- 空間計算量：O(m+n)
    - 同上

## Step 2. Alternatives

- これだけでも行けそう

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1: set = set(nums1)
        set2: set = set(nums2)
        intersection: set = set1 & set2
        return list(intersection)
```

- 出力をarrayにしてください、と言われていたのでarrayモジュールを使う必要があるのかと最初思ってしまったが普通にlistで行けた
    - むしろ整数型のarrayを返したらエラーになった
- メモリ的には二つ目のsetを作らない方が嬉しい

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1: set = set(nums1)
        intersect: set = set()
        for num in nums2:
            if num in set1:
                intersect.add(num)
        return list(intersect)
```

> 片方が大きくてもう片方が小さい場合
> 

https://github.com/fuga-98/arai60/pull/14/files#diff-1a10adf6bb0942f4a04d8c56ae7a7bc912bedec66cbbe6f69ef866e0bc211587R48

- 短い方をsetにする
    - メモリ消費を抑えられる

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if len(nums1) < len(nums2):
            base: set = set(nums1)
            iterate: list = nums2
        else:
            base: set = set(nums2)
            iterate: list = nums1
        intersect: set = set()
        for num in iterate:
            if num in base:
                intersect.add(num)
        return list(intersect)
```

- sortされてる前提だったら前の要素との重複を見る

## Step 3. Final Solution

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if len(nums1) < len(nums2):
            base: set = set(nums1)
            iterate: list = nums2
        else:
            base: set = set(nums2)
            iterate: list = nums1
        intersect: set = set()
        for num in iterate:
            if num in base:
                intersect.add(num)
        return list(intersect)
```
