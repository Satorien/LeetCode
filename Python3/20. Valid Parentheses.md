## Step 1. Initial Solution

- いまいちどうやったら効率よく確かめられるかが分からない
    - リストにして処理していく？
        - 別にリストにしなくても文字列を更新していけば良い
    - 再帰にする？
        - 最大長さ10000なので出来れば避けたい
    - 前から見て行って対応する閉じ括弧を探す？
        - 後ろから探しても前から探しても無理
    - マッチしたものから消していく？
        - これなら取りあえず問題はなさそう
        - 中心の括弧から順番に消していくのが良いか
            - 消したら再度ループし直す
        - 前と後をつなぐため、後ろは最後尾だと微妙
            - 別で処理する

```python
class Solution:
    def isValid(self, s: str) -> bool:
        remaining_string: str = s
        loop: bool = False
        while remaining_string:
            for i in range(len(remaining_string)-2):
                if remaining_string[i] == "(" and remaining_string[i+1] == ")":
                    remaining_string = remaining_string[:i] + remaining_string[i+2:]
                    loop = True
                    break
                if remaining_string[i] == "{" and remaining_string[i+1] == "}":
                    remaining_string = remaining_string[:i] + remaining_string[i+2:]
                    loop = True
                    break
                if remaining_string[i] == "[" and remaining_string[i+1] == "]":
                    remaining_string = remaining_string[:i] + remaining_string[i+2:]
                    loop = True
                    break
            if loop:
                loop = False
                continue

            if remaining_string != "()" and remaining_string != "{}" and remaining_string != "[]":
                return False
            else:
                remaining_string = ""
        return True
            
```

- 36分程度で提出

### Complexity Analysis

- 時間計算量：O(n!)
    - loopはあるが、段々文字列は短くなっていく
    - 全部が入れ子構造になっていた場合n/2の階乗回かかる
- 空間計算量：O(n)
    - 文字列分の長さ

## Step 2. Alternatives

- Initial Solutionを綺麗にするとこんな感じ

```python
class Solution:
    def isValid(self, s: str) -> bool:
        remaining_string: str = s
        while remaining_string:
            if "()" in remaining_string:
                remaining_string = remaining_string.replace("()", "")
            elif "{}" in remaining_string:
                remaining_string = remaining_string.replace("{}","")
            elif "[]" in remaining_string:
                remaining_string = remaining_string.replace("[]","")
            else:
                return False
        return True
```

- あまりに遅いので他の解法を見る
    - Stackを使う方法がある
    - これなら最大でもO(n)で終わる

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for letter in s:
            if stack and is_pair(stack[-1] + letter):
                stack.pop()
            else:
                stack.append(letter)
        return not stack

def is_pair(string: str) -> bool:
    if string == "()" or string == "{}" or string == "[]":
        return True
    else:
        return False
```

- Stackの底に番兵を置くのもありとのこと
    - 今回はなくても最後の判定が難しくないので入れなくても良さそう
- プッシュダウンオートマトンも連想したい
    - 順番にpushしていって、条件に一致する時だけpop
- 早くInvalidを見る方法もあるが、最後まで見るデメリットがさほど大きくないのでそのままで行く

## Step 3. Final Solution

- Stackを使う方法
- コードもすっきりしたので先に終われる場合は終われるようにした
- pairという命名はもう少し工夫できるかもしれない
- 最後のelse: breakはreturn Falseと迷った
    - そこにreturn処理があるのに違和感を覚えたがreturn Falseの方が分かりやすいのかもしれない

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for letter in s:
            if not stack or letter == "(" or letter == "{" or letter == "[":
                stack.append(letter)
                continue
            pair: str = stack[-1] + letter
            if pair == "()" or pair == "{}" or pair == "[]":
                stack.pop()
            else:
                break
        return not stack
```
