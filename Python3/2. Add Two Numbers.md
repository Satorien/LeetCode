## Initial Solution

- 同じ桁数の場合をイメージ
    - 筆算のように下から足していけば良い
    - 繰り上がりを考慮したい
- 桁数が大きく異なる場合
    - 片方が空ならみたいなことを続けるのは不毛？
    - 片方が空になったらもう片方を差し込んでしまえば良い
- 一旦答えに2つのリストを足しこんでいく方法を実装
    - 片方にもう片方を足しこんでいく方が無駄がない
        - 少し分かりにくい？
        - ネストがあるのも要修正

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        ret: ListNode = l1
        cur: ListNode = ret
        while cur:
            if l2:
                cur.val += l2.val
                l2 = l2.next

            if cur.val > 9:
                cur.val -= 10
                if cur.next:
                    cur.next.val += 1
                else:
                    cur.next = ListNode(1, None)
            if not cur.next:
                cur.next = l2
                l2 = None
            cur = cur.next
        return ret
```

### Complexity Analysis

- 時間計算量：O(n)
    - nは短い方のリストの長さ
- 空間計算量: O(1)
    - ListNode4つ分とブーレアン1つ

## Alternatives

- 和のリストを0のListNodeで初期化して足しこんでいく方
    - 処理が対照的で見やすい
    - やはり最大計算時間は増えてしまう
        - Submissionでは9ms差

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        lists_sum: ListNode = ListNode(0, None)
        digit: ListNode = lists_sum

        while digit:
            if l1:
                digit.val += l1.val
                l1 = l1.next
            if l2:
                digit.val += l2.val
                l2 = l2.next
            if digit.val > 9:
                digit.next = ListNode(1, None)
                digit.val -= 10
            if (l1 or l2) and not digit.next:
                digit.next = ListNode(0, None)
            digit = digit.next
        return lists_sum
```

- 条件ではなく、%や//で処理する方法もある
- dummy_headを用意して、nextに書き込んでいき、dummy_head.nextを返すというやり方もあるらしい
    - というかそのような人の方が多い？
    - LinkedListで返したいけど、一番下の値から入れていきたい、という要望を満たしている
    - 試しに実装
        - 全ループ共通で新規ノード作成できるから楽

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        sum_node: ListNode = ListNode()
        dummy_head: ListNode = sum_node
        carry: int = 0

        while l1 is not None or l2 is not None or carry==1:
            sum_node.next = ListNode(val=carry)
            sum_node = sum_node.next

            if l1:
                sum_node.val += l1.val
                l1 = l1.next
            if l2:
                sum_node.val += l2.val
                l2 = l2.next
            
            if sum_node.val >= 10:
                sum_node.val -= 10
                carry = 1
            else:
                carry = 0
            
        return dummy_head.next
```

- 再帰や整数に戻すといったやり方もありそうだが、特にメリットはなさそう

## Final Solution

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        node: ListNode = ListNode()
        dummy_head: ListNode = node
        carry: int = 0
        node.next = l1
        while node.next is not None:
            node = node.next
            if carry == 1:
                node.val += 1
            if l2 is not None:
                node.val += l2.val
                l2 = l2.next
            carry = node.val//10
            node.val %= 10
            
            if node.next is None and carry == 1:
                node.next = ListNode()
            elif node.next is None and l2 is not None:
                node.next = l2
                l2 = None
        return dummy_head.next
```

- carryとdummy_headを採用しつつ、l1にl2を足しこんでいく方法
    - 対称性はないが個人的にはイメージがしやすい
- 3回連続ACできるまでにかなり苦戦してしまった
    - 頭の中に整理された状態でロジックが出来ていないと上手くいかなかった
