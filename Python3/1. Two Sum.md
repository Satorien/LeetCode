## Step 1. Initial Solution

- targetを越えるまでfor文で回す？
    - sortされていないから下から見ていくのは微妙
    - かといってsortするとindexを返すのが面倒
- 問題文を読み直すと解は一意に定めるとあるがそうじゃない場合にも対応したいところ
- 良い案が思いつかないのでとりあえずO(n^2)で実装

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)-1):
            for j in range(i+1, len(nums)):
                if target - nums[i] == nums[j]:
                    return [i, j]
        return None
```

- sortしてから、というのも考えてみるがbinary_sortを自分で実装したあたりで力尽きて別の方法を探す
- HintにHashmapという言葉があり、なるほどと思う
    - setは使わなくても良いが長い時には速い
    - 今回の条件には問題ないが、複数同じ値が入っている場合には後ろの方のindexしか保存できない問題点はある

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen: set = set()
        idx_of: dict[int, int] = dict()
        for idx, num in enumerate(nums):
            if target - num in seen:
                return [idx, idx_of[target - num]]
            seen.add(num)
            idx_of[num] = idx
        return None
```

### Complexity Analysis

- 時間計算量：O(n)
    - in, add, dictの追加いずれも定数時間
- 空間計算量：O(n)
    - setとdictに最大n-1個

## Step 2. Alternatives

- 計算量のオーダーとしてはin dictもin setも同じ

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        idx_of: dict[int, int] = dict()
        for idx, num in enumerate(nums):
            if target - num in idx_of:
                return [idx, idx_of[target - num]]
            idx_of[num] = idx
        return None
```

- enumerateは少し遅い
    - generator objectを作る
    - 以下のコードと等価とのこと

```python
def enumerate(iterable, start=0):
    n = start
    for elem in iterable:
        yield n, elem
        n += 1
```

- 答えが見つからなかった場合は[]やValueErrorも選択肢にある
- 変数名はnum_to_idxとかが良いらしい
    - toとかを入れるのに若干抵抗があったが、分かりやすいならその方が良い

## Step 3. Final Solution

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        num_to_idx: Dict[int, int] = {}
        for i in range(len(nums)):
            if target - nums[i] in num_to_idx:
                return [num_to_idx[target - nums[i]], i]
            num_to_idx[nums[i]] = i
        return []
```
