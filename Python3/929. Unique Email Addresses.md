## Step 1. Initial Solution

- `@` の両側に区切って、local nameを処理してからdomain nameとくっつけてsetに入れる
    - `+` がlocal nameに入っていたらその前までとる
    - `.` はreplaceする
        - 初めはremoveで行けると思っていたがstr型ではないらしいので変更
- 異常入力の対処は正規表現を上手く思い出せずfor文で回す方法しか思いつかなかったので一旦省略

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_email: set = set()
        for email in emails:
            separation = email.find("@")
            local = email[:separation]
            ignore_head: int = local.find("+")
            if ignore_head != -1:
                local = local[:ignore_head]
            local = local.replace(".","")
            domain: str = email[separation+1:]
            unique_email.add(f"{local}@{domain}")
        return len(unique_email)
```

### Complexity Analysis

- 時間計算量：O(nk)
    - 文字列の長さに比例してfindやスライスコピーに要する
- 空間計算量：O(nk)
    - emailのコピーをlocalとdomainに取る

## Step 2. Alternatives

- 正規表現を調べて、実装してみた
    - `+`で始まるgroup(2)は無視

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_email: set = set()
        for email in emails:
            email_splits = re.match(r'([a-z.]+)([+]?[a-z.+]*)@([a-z.+]+)([.com])', email)
            if email_splits.group() != email:
                raise ValueError("Invalid email")
            local = email_splits.group(1)
            local = local.replace(".","")
            domain = email_splits.group(3)
            domain_suffix = email_splits.group(4)
            unique_email.add(f"{local}@{domain}{domain_suffix}")
        return len(unique_email)
```

ここからは他人のコードを参考に

- splitを使うと比較的簡単に書ける
    - splitを使う場合は、下の書き方だと複数@がある時にunpackできずエラーとなるが、max_split=1とすればエラーは避けれるので用途に応じて変える
    - RFCを見れば詳しいことは分かるらしい
        - 一旦このあたりにありそうということまでは分かったが時間がかかりそうなので中断
            - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_email: set = set()
        for email in emails:
            local, domain = email.split('@')
            local = local.split('+')[0]
            local = local.replace('.','')
            unique_email.add(f"{local}@{domain}")
        return len(unique_email)
```

- 正規表現を使わずに確かめる場合は以下のような方法がある

```python
all(ord("a") <= ord(c) <= ord("z") or c in ".+@" for c in email)
```

- このように細かくvalidationを定義するのはテスト駆動の考え方に近いように感じた
    - https://github.com/tokuhirat/LeetCode/pull/14/files
    - 関数化すると見通しは良い
    
    ```python
    class Solution:
        def numUniqueEmails(self, emails: List[str]) -> int:
            def is_valid_email(email):
                if re.match(r'[a-z.+]+@[a-z.+]+.com', email).group() == email:
                    return True
                return False
            def format_email(email):
                local, domain = email.split('@')
                local = local.split('+')[0].replace('.', '')
                return f'{local}@{domain}'
            unique_emails: Set[str] = set()
            for email in emails:
                if not is_valid_email(email):
                    continue
                unique_emails.add(format_email(email))
            return len(unique_emails)
                
    ```
    

## Step 3. Final Solution

- splitとreplaceの処理を2つに分けるか迷ったがこれに落ち着いた
- re.fullmatchの方がre.matchより良いことに気が付いた

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails: Set[int] = set()
        for email in emails:
            if re.fullmatch(r'[a-z.+]+@[a-z.+]+.com', email)[0] != email:
                raise ValueError("Invalid email given")
            local, domain = email.split('@')
            canonical_local = local.split('+')[0].replace('.', '')
            unique_emails.add(f'{canonical_local}@{domain}')
        return len(unique_emails)
```
